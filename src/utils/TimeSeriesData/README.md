# 时间序列数据

像 cr 这种数据，可以
只保存前两位数以及数量级。

使用[utf15](https://github.com/screepers/utf15)压缩数据。每 m 个位深度为 n 的整数会被转换成 ceil(m\*n/15)个 UTF-16 字符，在 screeps 里刚好对应为一个字节。

比如，每隔 15 分钟记录 cr 数据，那么一个月下来会记录 30\*24\*4=2880 次数据。

-   1.如果按照普通方法（假设占 10 字节，九位数）用数组记录的话，字节数为 28800=28KB。
-   2.如果按照普通方法只保存前两位以及数量级的话（假设占 5 字节）记录的话，字节数为 14400=14KB。
-   3.而使用 utf15 只保存前两位（位深度为 7（2\^7=128））以及数量级（位深度为 4（2\^4=16））的话，字节数为 ceil(2880\*7/15)+ceil(2880\*4/15)=1344+768=2112=2KB，是普通方法 1 的空间占用率的%7，是普通方法 2 的空间占用率的%14。
-   4.而使用 utf15 保存去掉整数后三位以及小数部分（位深度为 21（2\^21=2,097,152，可保存 20B））的话，字节数为 ceil(1440\*21/15)=2016=2KB，是普通方法 1 的空间占用率的%20，是普通方法 2 的空间占用率的%28。

再比如，每隔 15 分钟记录 upgradeProgress 数据，那么半个月（一般半个月左右满级）下来会记录 15\*24\*4=1440 次数据。

-   1.如果按照普通方法（假设平均占 7 字节）用数组记录的话，字节数为 1440\*7=20160=10KB。
-   2.如果按照普通方法只保存前两位以及数量级的话（假设占 5 字节）记录的话，字节数为 7200=7KB。
-   3.而使用 utf15 只保存前两位（位深度为 7（2\^7=128））以及数量级（位深度为 3（2\^3=8））的话，字节数为 ceil(1440\*7/15)+ceil(1440\*3/15)=1344/2+576/2=960=1KB，是普通方法 1 的空间占用率的%10，是普通方法 2 的空间占用率的%14。
-   4.而使用 utf15 保存（位深度为 21（2\^21=2,097,152>1,090,000））的话，字节数为 ceil(1440\*21/15)=2016=2KB，是普通方法 1 的空间占用率的%20，是普通方法 2 的空间占用率的%28。

在 RawMemory 进行数据保存。

该模块会自动压缩长时间不变的序列数据。

# 模块

-   storage 模块：

    1. 负责和 RawMemory 对接
    2. 存入和取出并编译所有要求的 JSON 数据。
    3. 只在创建该实例的 tick 使用。
    4. 自动切换使用的 segment 并删除过时的 segment 内容以保证内存不会占满

-   engine 模块：

    1. 负责检测和维护数据的时间戳
    2. 编译 utf15 字符串
    3. 决定是否进行存取以及存取哪些 RawMemory
    4. 同时按照输入数据类型进行数据的预处理（比如提取位数与数量级）
    5. 提前进行 active segment。
    6. 对长时间不变的序列数据进行压缩。
